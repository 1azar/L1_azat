package main

import (
	"fmt"
	"sync"
)

// УСЛОВИЕ:
// Дана последовательность чисел: 2,4,6,8,10.
// Найти сумму их квадратов(22+32+42….) с использованием конкурентных вычислений.

func main() {
	// Объявление и инициализация массива
	numbers := [...]int{2, 4, 6, 8, 10}

	// Канал для передачи результатов вычислений из конкурентно работающих горутин.
	// Буфер == размеру массива чтобы операция записи в канал не блокировала горутины из-за заполнения буфера
	// Не требует дополнительных механизмов синхронизации (конкурентно безопасный тип)
	resultChan := make(chan int, len(numbers))

	// Механизм синхронизации. Необходим чтобы заблокировать поток выполнения до момента отработки других горутин.
	// При запуске каждой горутины увеличиваем счетчик на 1. Отработанная горутина через указатель на *wg,
	// переданный как аргумент, вызывает метод wg.Done(), что уменьшит счетчик на 1. wg.Wait() блокирует выполнение
	// до момента когда счетчик == 0
	var wg sync.WaitGroup

	// Запускаем горутины для каждого числа из массива
	for _, num := range numbers { // итерация по массиву, запись элемента массива в num
		wg.Add(1) // Инкрементация счетчика WaitGroup'ы
		// Запуск горутины с аргументами:
		// num - число для возведения в квадрат;
		// resultChan - канал для записи;
		// &wg - указатель на экземпляр WaitGroup для сообщения об отработки горутины
		go square(num, resultChan, &wg)
	}

	// Горутина для закрытия канала после завершения всех горутин
	go func() {
		wg.Wait()         // место блокировки до момента когда счетчик wg не будет == 0
		close(resultChan) // закрытие канала после отработки всех горутин
	}()

	sum := 0 // переменная для хранения суммы
	// Цикл по каналу будет выполнятся пока канал не закроется. Если канал опустеет (в канал не успели положить данные
	// к началу итерации) то цикл заблокируется до появления данных для чтения. Если не закрывать канал будет deadlock
	for result := range resultChan {
		sum += result // добавление к переменной суммы значение полученное из канала
	}
	fmt.Println("Сумма квадратов = ", sum)

	fmt.Println("Job is done!")
}

func square(number int, resultChan chan int, wg *sync.WaitGroup) {
	defer wg.Done()           // defer - отложенное выполнение функции. Декрементирует счетчик wg после выполнения функции
	result := number * number // Возведение в квадрат
	resultChan <- result      // отправка результата в канал
}
