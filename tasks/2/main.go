package main

import (
	"fmt"
	"sync"
)

// УСЛОВИЕ:
// Написать программу, которая конкурентно рассчитает значение квадратов чисел
// взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout.

func main() {
	// Объявление и инициализация массива
	numbers := [...]int{2, 4, 6, 8, 10}

	// Канал для передачи результатов вычислений из конкурентно работающих горутин.
	// Буфер == размеру массива чтобы операция записи в канал не блокировала горутины из-за заполнения буфера
	// Не требует дополнительных механизмов синхронизации (конкурентно безопасный тип)
	resultChan := make(chan int, len(numbers))

	// Механизм синхронизации. Необходим чтобы заблокировать поток выполнения до момента отработки других горутин.
	// При запуске каждой горутины увеличиваем счетчик на 1. Отработанная горутина через указатель на *wg,
	// переданный как аргумент, вызывает метод wg.Done(), что уменьшит счетчик на 1. wg.Wait() блокирует выполнение
	// до момента когда счетчик == 0
	var wg sync.WaitGroup

	// Запускаем горутины для каждого числа из массива
	for _, num := range numbers { // итерация по массиву, запись элемента массива в num
		wg.Add(1) // Инкрементация счетчика WaitGroup'ы
		// Запуск горутины с аргументами:
		// num - число для возведения в квадрат;
		// resultChan - канал для записи;
		// &wg - указатель на экземпляр WaitGroup для сообщения об отработки горутины
		go square(num, resultChan, &wg)
	}

	// Горутина для закрытия канала после завершения всех горутин
	go func() {
		wg.Wait()         // место блокировки до момента когда счетчик wg не будет == 0
		close(resultChan) // закрытие канала после отработки всех горутин
	}()

	// Цикл по каналу будет выполнятся пока канал не закроется. Если канал опустеет (в канал не успели положить данные
	// к началу итерации) то цикл заблокируется до появления данных для чтения. Если не закрывать канал будет deadlock
	for result := range resultChan {
		fmt.Println(result) // Порядок вывода будет различен от запуска к запуску.
	}

	fmt.Println("Job is done!")
}

func square(number int, resultChan chan int, wg *sync.WaitGroup) {
	defer wg.Done()           // defer - отложенное выполнение функции. Декрементирует счетчик wg после выполнения функции
	result := number * number // Возведение в квадрат
	resultChan <- result      // отправка результата в канал
}
