package main

import (
	"fmt"
	"log"
	"os"
	"os/signal"
	"strconv"
	"sync"
	"syscall"
)

// УСЛОВИЕ:
// Реализовать постоянную запись данных в канал (главный поток).
// Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
// Необходима возможность выбора количества воркеров при старте.

// RandomData набор произвольных данных которые будут отправляться в канал.
var RandomData []interface{} = []interface{}{
	"text_msg",
	"Привет МИР!",
	"c1b9c3ce-e0e3-41a2-83d7-7e7d8733f7d6",
	"MAY THE FORCE BE WITH YOU",
	999,
	-1234,
	0x2AD43,
	0.31415,
	struct {
		Name string
		Age  int
	}{"Alice", 28},
	func() {
		fmt.Printf("Hello from lambda")
	},
	[...]int{1, 2, 3, 4},
	[]byte{5, 5, 5},
	map[int]string{1: "Monday", 2: "Tuesday"},
}

func main() {
	// определение количества workers
	workersNum := 4        // по умолчанию 4 воркера
	if len(os.Args) == 2 { // кастомное количество воркеров задается аргументов командной строки при запуске
		var err error
		workersNum, err = strconv.Atoi(os.Args[1]) // $ go run main.go <количество работников>
		if err != nil {
			log.Fatalln("Использование: go run main.go <количество работников[int]>")
		}
	}

	// Подготовка канала в который будут записываться данные.
	// Не буферизированный, значит, что операция записи блокируется пока другая горутина не будет готова забрать данные
	dataChan := make(chan any) // канал для произвольных данных

	// Канал для остановки работы программы.
	// Если в канале кладется значение, то это сигнал к прекращению работы программы.
	// Буферизированный с емкостью 1 чтобы горутина которая положит сигнал в канал не ждала пока ее считают (не блокировалась)
	stop := make(chan os.Signal, 1)
	// при закрытии терминала, Ctr+C и других способах прерывания или завершения программы в канал stop отправится объект, что послужит сигналом к завершению программы
	signal.Notify(stop, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

	// Механизм синхронизации
	var wg sync.WaitGroup
	// создание воркеров, которые будут слушать канал, брать данные и выводить в консоль
	for i := 0; i < workersNum; i++ {
		wg.Add(1)
		go worker(i, dataChan, &wg)
	}

	// Запуск горутины который постоянно записывает данные в канал
	go func() {
		counter := 0
	senderLoop: // Метка цикла чтобы по ней остановить выполнение for
		for {
			counter++
			select {
			case <-stop:
				// Это логика выполнится когда попросят завершить работу программы
				close(dataChan) // Канал закроется. Воркеры считают оставшиеся данные в буфере и потом завершат работу
				fmt.Printf("\tSent %d messgaes\n", counter-1)
				// выти из цикла for, чтобы прекратить записывать новые данные в канал
				// Без метки цикла break применялся бы к select, а не for
				break senderLoop
			default:
				// Эта логика выполняется по умолчанию если нет других кейсов (нет сигнала о завершении программы)
				dataChan <- fmt.Sprintf("message\t%d", counter)
				//dataChan <- RandomData[rand.Intn(len(RandomData))] // Случайный элемент из набора отправляется канал
			}
		}
	}()

	wg.Wait()
	fmt.Println("Главный поток завершился")

}

// Worker имеет свой идентификатор - id, канал для чтения ch и указатель на WaitGroup чтобы по нему сообщить о завершении работы
func worker(id int, ch <-chan any, wg *sync.WaitGroup) {
	defer wg.Done() // Декрементирует счетчик wg когда завершить работу
	fmt.Printf("Worker %d: READY!\n", id)
	// Слушает канал пока тот не закроется
	for msg := range ch {
		// Хоть горутины считывают данные из одного канала в том порядке, в котором их записывали. Вывод в консоли
		// не гарантирует такой же порядок сообщений тк рантайм может переключить контекст на следующую горутину
		// в момент вывода сообщения, тогда при возврате контекста снова к изначальной горутине она выведет в консоль
		// сначала то значение которое успела считать в предыдущей итерации, а дальше продолжит считывать из канала
		// актуальные сообщения:
		//Worker 1: message       4675
		//Worker 1: message       4676
		//Worker 1: message       4677
		//Worker 1: message       4678
		//Worker 3: message       4097 <- 3 горутина считала это значение на предыдущей итерации, но перед выводом в консоль рантайм переключил контекст, поэтому при возврате контекста выполнение продолжилось с вывода этого значения
		//Worker 3: message       4680 <- актуальные сообщения в из канала. Сообщение 4679 выведется когда контекст вернется к Worker 1
		//Worker 3: message       4681
		//Worker 3: message       4682
		fmt.Printf("Worker %d: %v\n", id, msg)
	}
	fmt.Printf("Worker %d: SHUTS DOWN\n", id)
}
