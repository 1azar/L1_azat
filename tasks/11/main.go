package main

import "fmt"

// УСЛОВИЕ:
// Реализовать пересечение двух неупорядоченных множеств.

func main() {

	set1 := []int{13, 2, 34, 21, 4, 55, 6, 7, 5, 70, 19}
	set2 := []int{710, 20, 30, 340, 50, 2, 70}

	fmt.Println(Intersect1(set1, set2))
	fmt.Println(Intersect2(set1, set2))

}

// Intersect1 для каждого значения в первом слайсе проверят все значения во втором, если есть совпадения,
// то добавляет в результирующий слайс: O(n^2)
// Используются дженерики тк не ясно множества какого типа используются, поэтому рады всем comparable
func Intersect1[T comparable](a []T, b []T) []T {
	set := make([]T, 0)

	for _, v := range a {
		for _, v2 := range b {
			if v == v2 {
				set = append(set, v)
				continue
			}
		}
	}

	return set
}

// Intersect2 использует хэш таблицу O(n). Все значения 1го множества записывает как ключи мапы,
// потом итерирует по 2му множеству и проверяет есть ли такой ключ в мапе, если да, то это общий элемент множеств.
// Поиск по мапе имеет сложность O(1) поэтому это эффективнее чем итерировать по множеству.
func Intersect2[T comparable](a []T, b []T) []T {
	set := make([]T, 0)          // тут сохраняем пересекаемые значения
	hash := make(map[T]struct{}) // Хэшмапа тк имеет O(1) на получение значений, используется для хранения информации о том, встречалось ли значение раньше.

	for _, v := range a { // Записываем все элементы 1го множества как ключи map, а в значение кладем пустую структуру для экономии памяти
		hash[v] = struct{}{}
	}

	for _, v := range b { // Итерируемся по 2му множеству и проверяю есть ли ключ в hash == значению элемента (v). Если да, то это пересечение -> записываем в результирующий сет
		if _, ok := hash[v]; ok {
			set = append(set, v)
		}
	}

	return set
}
